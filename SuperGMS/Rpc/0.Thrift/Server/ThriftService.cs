#pragma warning disable   // Using directives should be ordered alphabetically by namespace

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 *  这个文件是thrift工具生成的csharp代理，不要改动
 */

using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Primitives;

using SuperGMS.Log;

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

using Thrift;
using Thrift.Processor;
using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;
using Thrift.Transport;

namespace SuperGMS.Rpc.Thrift.Server
{
    public partial class ThriftService
    {
        public class Client : TBaseClient, IDisposable, IAsync
        {
            public Client(TProtocol protocol) : this(protocol, protocol)
            {
            }

            public Client(TProtocol inputProtocol, TProtocol outputProtocol) : base(inputProtocol, outputProtocol)
            {
            }

            public async global::System.Threading.Tasks.Task<string> Send(string my_args, object appContext, CancellationToken cancellationToken = default)
            {
                await send_Send(my_args, cancellationToken);
                return await recv_Send(cancellationToken);
            }

            public async global::System.Threading.Tasks.Task send_Send(string my_args, CancellationToken cancellationToken = default)
            {
                await OutputProtocol.WriteMessageBeginAsync(new TMessage("Send", TMessageType.Call, SeqId), cancellationToken);

                var tmp0 = new InternalStructs.Send_args()
                {
                    My_args = my_args,
                };

                await tmp0.WriteAsync(OutputProtocol, cancellationToken);
                await OutputProtocol.WriteMessageEndAsync(cancellationToken);
                await OutputProtocol.Transport.FlushAsync(cancellationToken);
            }

            public async global::System.Threading.Tasks.Task<string> recv_Send(CancellationToken cancellationToken = default)
            {

                var tmp1 = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
                if (tmp1.Type == TMessageType.Exception)
                {
                    var tmp2 = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
                    await InputProtocol.ReadMessageEndAsync(cancellationToken);
                    throw tmp2;
                }

                var tmp3 = new InternalStructs.Send_result();
                await tmp3.ReadAsync(InputProtocol, cancellationToken);
                await InputProtocol.ReadMessageEndAsync(cancellationToken);
                if (tmp3.__isset.success)
                {
                    return tmp3.Success;
                }
                throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "Send failed: unknown result");
            }

        }

        public class AsyncProcessor : ITAsyncProcessor
        {
            private readonly IAsync _iAsync;
            private readonly ILogger<AsyncProcessor> _logger;

            public AsyncProcessor(IAsync iAsync, ILogger<AsyncProcessor> logger = default)
            {
                _iAsync = iAsync ?? throw new ArgumentNullException(nameof(iAsync));
                _logger = logger;
                processMap_["Send"] = Send_ProcessAsync;
            }

            protected delegate global::System.Threading.Tasks.Task ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken);
            protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

            public async Task<bool> ProcessAsync(TProtocol iprot, TProtocol oprot)
            {
                return await ProcessAsync(iprot, oprot, CancellationToken.None);
            }

            public async Task<bool> ProcessAsync(TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
            {
                try
                {
                    var msg = await iprot.ReadMessageBeginAsync(cancellationToken);

                    processMap_.TryGetValue(msg.Name, out var fn);

                    if (fn == null)
                    {
                        await TProtocolUtil.SkipAsync(iprot, TType.Struct, cancellationToken);
                        await iprot.ReadMessageEndAsync(cancellationToken);
                        var x = new TApplicationException(TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
                        await oprot.WriteMessageBeginAsync(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID), cancellationToken);
                        await x.WriteAsync(oprot, cancellationToken);
                        await oprot.WriteMessageEndAsync(cancellationToken);
                        await oprot.Transport.FlushAsync(cancellationToken);
                        return true;
                    }

                    await fn(msg.SeqID, iprot, oprot, cancellationToken);

                }
                catch (IOException)
                {
                    return false;
                }

                return true;
            }

            public async global::System.Threading.Tasks.Task Send_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
            {
                var tmp4 = new InternalStructs.Send_args();
                await tmp4.ReadAsync(iprot, cancellationToken);
                await iprot.ReadMessageEndAsync(cancellationToken);
                var tmp5 = new InternalStructs.Send_result();
                try
                {
                    tmp5.Success = await _iAsync.Send(tmp4.My_args, cancellationToken);
                    await oprot.WriteMessageBeginAsync(new TMessage("Send", TMessageType.Reply, seqid), cancellationToken);
                    await tmp5.WriteAsync(oprot, cancellationToken);
                }
                catch (TTransportException)
                {
                    throw;
                }
                catch (Exception tmp6)
                {
                    var tmp7 = $"Error occurred in {GetType().FullName}: {tmp6.Message}";
                    if (_logger != null)
                        _logger.LogError("{Exception}, {Message}", tmp6, tmp7);
                    else
                        Console.Error.WriteLine(tmp7);
                    var tmp8 = new TApplicationException(TApplicationException.ExceptionType.InternalError, " Internal error.");
                    await oprot.WriteMessageBeginAsync(new TMessage("Send", TMessageType.Exception, seqid), cancellationToken);
                    await tmp8.WriteAsync(oprot, cancellationToken);
                }
                await oprot.WriteMessageEndAsync(cancellationToken);
                await oprot.Transport.FlushAsync(cancellationToken);
            }

        }

        public class InternalStructs
        {

            public partial class Send_args : TBase
            {
                private string _my_args;

                public string My_args
                {
                    get
                    {
                        return _my_args;
                    }
                    set
                    {
                        __isset.my_args = true;
                        this._my_args = value;
                    }
                }


                public Isset __isset;
                public struct Isset
                {
                    public bool my_args;
                }

                public Send_args()
                {
                }

                public Send_args DeepCopy()
                {
                    var tmp9 = new Send_args();
                  if ((My_args != null) && __isset.my_args)
                    {
                        tmp9.My_args = this.My_args;
                    }
                    tmp9.__isset.my_args = this.__isset.my_args;
                    return tmp9;
                }

                public async global::System.Threading.Tasks.Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
                {
                    iprot.IncrementRecursionDepth();
                    try
                    {
                        TField field;
                        await iprot.ReadStructBeginAsync(cancellationToken);
                        while (true)
                        {
                            field = await iprot.ReadFieldBeginAsync(cancellationToken);
                            if (field.Type == TType.Stop)
                            {
                                break;
                            }

                            switch (field.ID)
                            {
                                case 1:
                                    if (field.Type == TType.String)
                                    {
                                        My_args = await iprot.ReadStringAsync(cancellationToken);
                                    }
                                    else
                                    {
                                        await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
                                    }
                                    break;
                                default:
                                    await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
                                    break;
                            }

                            await iprot.ReadFieldEndAsync(cancellationToken);
                        }

                        await iprot.ReadStructEndAsync(cancellationToken);
                    }
                    finally
                    {
                        iprot.DecrementRecursionDepth();
                    }
                }

                public async global::System.Threading.Tasks.Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
                {
                    oprot.IncrementRecursionDepth();
                    try
                    {
                        var tmp10 = new TStruct("Send_args");
                        await oprot.WriteStructBeginAsync(tmp10, cancellationToken);
                        var tmp11 = new TField();
                        if ((My_args != null) && __isset.my_args)
                        {
                            tmp11.Name = "my_args";
                            tmp11.Type = TType.String;
                            tmp11.ID = 1;
                            await oprot.WriteFieldBeginAsync(tmp11, cancellationToken);
                            await oprot.WriteStringAsync(My_args, cancellationToken);
                            await oprot.WriteFieldEndAsync(cancellationToken);
                        }
                        await oprot.WriteFieldStopAsync(cancellationToken);
                        await oprot.WriteStructEndAsync(cancellationToken);
                    }
                    finally
                    {
                        oprot.DecrementRecursionDepth();
                    }
                }

                public override bool Equals(object that)
                {
                    if (!(that is Send_args other)) return false;
                    if (ReferenceEquals(this, other)) return true;
                    return ((__isset.my_args == other.__isset.my_args) && ((!__isset.my_args) || (global::System.Object.Equals(My_args, other.My_args))));
                }

                public override int GetHashCode()
                {
                    int hashcode = 157;
                    unchecked
                    {
                        if ((My_args != null) && __isset.my_args)
                        {
                            hashcode = (hashcode * 397) + My_args.GetHashCode();
                        }
                    }
                    return hashcode;
                }

                public override string ToString()
                {
                    var tmp12 = new StringBuilder("Send_args(");
                    int tmp13 = 0;
                    if ((My_args != null) && __isset.my_args)
                    {
                        if (0 < tmp13++) { tmp12.Append(", "); }
                        tmp12.Append("My_args: ");
                        My_args.ToString(tmp12);
                    }
                    tmp12.Append(')');
                    return tmp12.ToString();
                }
            }


            public partial class Send_result : TBase
            {
                private string _success;

                public string Success
                {
                    get
                    {
                        return _success;
                    }
                    set
                    {
                        __isset.@success = true;
                        this._success = value;
                    }
                }


                public Isset __isset;
                public struct Isset
                {
                    public bool @success;
                }

                public Send_result()
                {
                }

                public Send_result DeepCopy()
                {
                    var tmp14 = new Send_result();
                  if ((Success != null) && __isset.@success)
                    {
                        tmp14.Success = this.Success;
                    }
                    tmp14.__isset.@success = this.__isset.@success;
                    return tmp14;
                }

                public async global::System.Threading.Tasks.Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
                {
                    iprot.IncrementRecursionDepth();
                    try
                    {
                        TField field;
                        await iprot.ReadStructBeginAsync(cancellationToken);
                        while (true)
                        {
                            field = await iprot.ReadFieldBeginAsync(cancellationToken);
                            if (field.Type == TType.Stop)
                            {
                                break;
                            }

                            switch (field.ID)
                            {
                                case 0:
                                    if (field.Type == TType.String)
                                    {
                                        Success = await iprot.ReadStringAsync(cancellationToken);
                                    }
                                    else
                                    {
                                        await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
                                    }
                                    break;
                                default:
                                    await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
                                    break;
                            }

                            await iprot.ReadFieldEndAsync(cancellationToken);
                        }

                        await iprot.ReadStructEndAsync(cancellationToken);
                    }
                    finally
                    {
                        iprot.DecrementRecursionDepth();
                    }
                }

                public async global::System.Threading.Tasks.Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
                {
                    oprot.IncrementRecursionDepth();
                    try
                    {
                        var tmp15 = new TStruct("Send_result");
                        await oprot.WriteStructBeginAsync(tmp15, cancellationToken);
                        var tmp16 = new TField();

                        if (this.__isset.@success)
                        {
                            if (Success != null)
                            {
                                tmp16.Name = "Success";
                                tmp16.Type = TType.String;
                                tmp16.ID = 0;
                                await oprot.WriteFieldBeginAsync(tmp16, cancellationToken);
                                await oprot.WriteStringAsync(Success, cancellationToken);
                                await oprot.WriteFieldEndAsync(cancellationToken);
                            }
                        }
                        await oprot.WriteFieldStopAsync(cancellationToken);
                        await oprot.WriteStructEndAsync(cancellationToken);
                    }
                    finally
                    {
                        oprot.DecrementRecursionDepth();
                    }
                }

                public override bool Equals(object that)
                {
                    if (!(that is Send_result other)) return false;
                    if (ReferenceEquals(this, other)) return true;
                    return ((__isset.@success == other.__isset.@success) && ((!__isset.@success) || (global::System.Object.Equals(Success, other.Success))));
                }

                public override int GetHashCode()
                {
                    int hashcode = 157;
                    unchecked
                    {
                        if ((Success != null) && __isset.@success)
                        {
                            hashcode = (hashcode * 397) + Success.GetHashCode();
                        }
                    }
                    return hashcode;
                }

                public override string ToString()
                {
                    var tmp17 = new StringBuilder("Send_result(");
                    int tmp18 = 0;
                    if ((Success != null) && __isset.@success)
                    {
                        if (0 < tmp18++) { tmp17.Append(", "); }
                        tmp17.Append("Success: ");
                        Success.ToString(tmp17);
                    }
                    tmp17.Append(')');
                    return tmp17.ToString();
                }
            }

        }

    }
}

#pragma warning restore // Using directives should be ordered alphabetically by namespace